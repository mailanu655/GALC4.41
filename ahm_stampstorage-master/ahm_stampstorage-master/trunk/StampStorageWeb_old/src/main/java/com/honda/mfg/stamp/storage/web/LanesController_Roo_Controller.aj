// WARNING: DO NOT EDIT THIS FILE. THIS FILE IS MANAGED BY SPRING ROO.
// You may push code into the target .java compilation unit if you wish to edit any member(s).

package com.honda.mfg.stamp.storage.web;

import com.honda.mfg.stamp.conveyor.domain.*;
import com.honda.mfg.stamp.conveyor.domain.enums.*;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.util.UriUtils;
import org.springframework.web.util.WebUtils;

import javax.servlet.http.HttpServletRequest;
import java.io.UnsupportedEncodingException;
import java.util.*;

privileged aspect  LanesController_Roo_Controller {

//    @RequestMapping(params = "rows", method = RequestMethod.GET)
//    public String LanesController.list(@RequestParam(value = "page", required = false) Integer page, @RequestParam(value = "size", required = false) Integer size, Model uiModel) {
//
//        //2013-01-31:VB:trying to eliminate storage state: List<StorageRow> lanes = carrierManagementService.getStorageState().getLanes();
//    	/* 2013-02-01:VB: This is one way of doing it...
//        List<StorageRow> allLanes = carrierManagementService.getStorageRowsForDetailedInventory();
//        List<StorageRow> chighlanes = filterCarriersInLanes(1200L, 1221L, allLanes);
//        List<StorageRow> aArealanes = filterCarriersInLanes(1220L, 1230L, allLanes);
//        List<StorageRow> clowlanes = filterCarriersInLanes(1229L, 1236L, allLanes);
//
//        List<StorageRow> lanes = new ArrayList<StorageRow>();
//        lanes.addAll(chighlanes);
//        lanes.addAll(aArealanes);
//        lanes.addAll(clowlanes);
//        */
//    	//but a better way may be...
//    	List<StorageRow> lanes = getAllLanes();
//        List<StorageRow> tempLanes = new ArrayList<StorageRow>();
//        for (StorageRow lane : lanes) {
//            if (lane.getLaneCondition().equals(LaneCondition.MIXED)) {
//                for (Long dieNumber : lane.getDieNumbersForAllCarriers()) {
//                    StorageRow tempLane = new StorageRow();
//                    tempLane.setLaneCondition(LaneCondition.MIXED);
//                    Die die = Die.findDie(dieNumber);
//                    LinkedList<Carrier> carrierlist = lane.getCarriersAsLinkedList();
//                    while (!carrierlist.isEmpty()) {
//                        Carrier carrier = carrierlist.remove();
//                        if (carrier.getDie().equals(die)) {
//                            tempLane.store(carrier);
//                        }
//                    }
//                    tempLanes.add(tempLane);
//                }
//            } else {
//                StorageRow tempLane = new StorageRow();
//                LinkedList<Carrier> carrierlist = lane.getCarriersAsLinkedList();
//                while (!carrierlist.isEmpty()) {
//                    Carrier carrier = carrierlist.remove();
//                    tempLane.store(carrier);
//                }
//                tempLanes.add(tempLane);
//            }
//
//        }
//
//        if (page != null || size != null) {
//            int sizeNo = size == null ? 10 : size.intValue();
//            List<StorageRow> pageLanes = new ArrayList<StorageRow>();
//
//            int i = (page.intValue() - 1) * size;
//            int count = 0;
//
//            while (count < size && i < tempLanes.size()) {
//                pageLanes.add(tempLanes.get(i));
//                i++;
//                count++;
//            }
//            uiModel.addAttribute("lanes", pageLanes);
//            float nrOfPages = (float) tempLanes.size() / sizeNo;
//            uiModel.addAttribute("maxPages", (int) ((nrOfPages > (int) nrOfPages || nrOfPages == 0.0) ? nrOfPages + 1 : nrOfPages));
//        } else {
//            uiModel.addAttribute("lanes", tempLanes);
//        }
//
//
//        return "lanes/list";
//    }

    String LanesController.encodeUrlPathSegment(String pathSegment, HttpServletRequest httpServletRequest) {
        String enc = httpServletRequest.getCharacterEncoding();
        if (enc == null) {
            enc = WebUtils.DEFAULT_CHARACTER_ENCODING;
        }
        try {
            pathSegment = UriUtils.encodePathSegment(pathSegment, enc);
        } catch (UnsupportedEncodingException uee) {
        }
        return pathSegment;
    }

    @RequestMapping(method = RequestMethod.GET)
    public String LanesController.listLanes(@RequestParam(value = "page", required = false) Integer page, @RequestParam(value = "size", required = false) Integer size, Model uiModel) {

        List<List<StorageRow>> rows = new ArrayList<List<StorageRow>>();

        for (StorageArea area : StorageArea.values()) {
            rows.add(filterCarriersInLanes(StorageRow.findStorageRowsByArea(area)));
        }

        uiModel.addAttribute("rows", rows);
        uiModel.addAttribute("areas", StorageArea.values());

        return "lanes/detailedInventory";
    }

    @RequestMapping(params = "overview", method = RequestMethod.GET)
    public String LanesController.listOverviewRows(@RequestParam(value = "page", required = false) Integer page, @RequestParam(value = "size", required = false) Integer size, Model uiModel) {

        List<StorageRow> chighlanes = filterCarriersInLanes(StorageRow.findStorageRowsByArea(StorageArea.C_HIGH));
        List<StorageRow> aarealanes = filterCarriersInLanes(StorageRow.findStorageRowsByArea(StorageArea.A_AREA));
        List<StorageRow> clowlanes = filterCarriersInLanes(StorageRow.findStorageRowsByArea(StorageArea.C_LOW));
        //20130607 GSA - include B, Q and S lanes
        List<StorageRow> barealanes = filterCarriersInLanes(StorageRow.findStorageRowsByArea(StorageArea.B_AREA));
        List<StorageRow> qarealanes = filterCarriersInLanes(StorageRow.findStorageRowsByArea(StorageArea.Q_AREA));
        List<StorageRow> sarealanes = filterCarriersInLanes(StorageRow.findStorageRowsByArea(StorageArea.S_AREA));

        List<com.honda.mfg.stamp.conveyor.domain.Model> modelList = com.honda.mfg.stamp.conveyor.domain.Model.findActiveModels();

        boolean mesHealthy = !carrierManagementService.isDisconnected();
        uiModel.addAttribute("meshealthy", mesHealthy);
        uiModel.addAttribute("alarmevent", carrierManagementService.getAlarmEventToDisplay());
        uiModel.addAttribute("models", modelList);
        uiModel.addAttribute("chighrows", chighlanes);
        uiModel.addAttribute("clowrows", clowlanes);
        uiModel.addAttribute("aarearows", aarealanes);
        //20130607 GSA - include B, Q and S lanes
        uiModel.addAttribute("barearows", barealanes);
        uiModel.addAttribute("qarearows", qarealanes);
        uiModel.addAttribute("sarearows", sarealanes);

        return "lanes/overview";
    }

    @RequestMapping(params = "storageState", method = RequestMethod.GET)
    public String LanesController.showStorageState(Model uiModel) {
        // This method evaluates storage state consistency with what is in the database

        //StorageState state = carrierManagementService.getStorageState();

        //2013-02-01:VB:Eliminating storage state in web component:
        //List<StorageRow> ssRows = carrierManagementService.getStorageState().getLanes();
        //List<LaneImpl> ssRows = carrierManagementService.getStorageRowsForDetailedInventory();


        List<StorageRow> chighrows = StorageRow.findStorageRowsByArea(StorageArea.C_HIGH);
        List<StorageRow> aarearows = StorageRow.findStorageRowsByArea(StorageArea.A_AREA);
        List<StorageRow> clowrows = StorageRow.findStorageRowsByArea(StorageArea.C_LOW);
        //20130607 GSA - include B, Q and S lanes
        List<StorageRow> barearows = StorageRow.findStorageRowsByArea(StorageArea.B_AREA);
        List<StorageRow> qarearows = StorageRow.findStorageRowsByArea(StorageArea.Q_AREA);
        List<StorageRow> sarearows = StorageRow.findStorageRowsByArea(StorageArea.S_AREA);

        List<com.honda.mfg.stamp.conveyor.domain.Model> modelList = com.honda.mfg.stamp.conveyor.domain.Model.findActiveModels();

        boolean mesHealthy = !carrierManagementService.isDisconnected();
        uiModel.addAttribute("meshealthy", mesHealthy);
        uiModel.addAttribute("alarmevent", carrierManagementService.getAlarmEventToDisplay());
        uiModel.addAttribute("models", modelList);
        uiModel.addAttribute("chighrows", chighrows);
        uiModel.addAttribute("aarearows", aarearows);
        uiModel.addAttribute("clowrows", clowrows);
        //20130607 GSA - include B, Q and S lanes
        uiModel.addAttribute("barearows", barearows);
        uiModel.addAttribute("qarearows", qarearows);
        uiModel.addAttribute("sarearows", sarearows);

        uiModel.addAttribute("loadTimestamp", new Date());

        return "lanes/storageState";
    }

    @RequestMapping(params = "storageState=refresh", method = RequestMethod.GET)
    public String LanesController.refreshStorageState(Model uiModel) {
        LOG.info("Manual StorageState refresh initiated by: " + getSource());
        carrierManagementServiceProxy.refreshStorageState();

        return "redirect:/lanes?storageState=-";

    }

    @RequestMapping(params = "overlay", method = RequestMethod.GET)
    public String LanesController.overlayForm(@RequestParam(value = "page", required = false) Integer page, @RequestParam(value = "size", required = false) Integer size, Model uiModel) {
        return "lanes/overlay";
    }

    @RequestMapping(params = "inventory", method = RequestMethod.GET)
    public String LanesController.getInventory(@RequestParam(value = "page", required = false) Integer page, @RequestParam(value = "size", required = false) Integer size, Model uiModel) {

        /*KD Line*/
        List<DieInventory> kDDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.KD_LINE);
        uiModel.addAttribute("kDDieInventory", kDDieInventory);

        /*Entire Storage System (no KD)*/
        List<DieInventory> dieInventory = getDieInventoryWithOutKDInventory(CarrierMes.findPartCountsByDies(), kDDieInventory);
        uiModel.addAttribute("dieInventory", dieInventory);

        /*In Storage All Rows*/
        List<DieInventory> rowDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.ROW);
        uiModel.addAttribute("rowDieInventory", rowDieInventory);

        /*Empty Area*/
        List<DieInventory> emptyAreaDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.EMPTY_AREA);
        uiModel.addAttribute("emptyAreaDieInventory", emptyAreaDieInventory);

        /*Old Weld Line (Empty)*/
        List<DieInventory> oldWeldDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.OLD_WELD_LINE);
        uiModel.addAttribute("oldWeldDieInventory", oldWeldDieInventory);

        /*Weld Line 2*/
        List<DieInventory> weldTwoDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.WELD_LINE_2);
        uiModel.addAttribute("weldTwoDieInventory", weldTwoDieInventory);

        /*Weld Line 1*/
        List<DieInventory> weldOneDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.WELD_LINE_1);
        uiModel.addAttribute("weldOneDieInventory", weldOneDieInventory);

        /*Store-Out*/
        List<DieInventory> storeOutDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.STORE_OUT_ROUTE);
        uiModel.addAttribute("storeOutDieInventory", storeOutDieInventory);

        /*Store-In*/
        List<DieInventory> storeInDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.STORE_IN_ROUTE);
        uiModel.addAttribute("storeInDieInventory", storeInDieInventory);

        /*C Press Area*/
        List<DieInventory> cPressDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.C_PRESS);
        uiModel.addAttribute("cPressDieInventory", cPressDieInventory);

        /*B Press Area*/
        List<DieInventory> bPressDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.B_PRESS);
        uiModel.addAttribute("bPressDieInventory", bPressDieInventory);

        //20130614 GSA - Add Q Area Totals        
        /*Q Area*/
        List<DieInventory> qWeldLine2AreaDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.Q_WELD_LINE_2);
        uiModel.addAttribute("qWE2AreaDieInventory",qWeldLine2AreaDieInventory);

         List<DieInventory> qWeldLine1AreaDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.Q_WELD_LINE_1);
        uiModel.addAttribute("qWE1AreaDieInventory", qWeldLine1AreaDieInventory);

        //20130614 GSA - Add B Area Empty Totals    
        /*B Area*/
        List<DieInventory> bAreaDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.B_AREA);
        uiModel.addAttribute("bAreaDieInventory", bAreaDieInventory);

        boolean mesHealthy = !carrierManagementService.isDisconnected();
        uiModel.addAttribute("meshealthy", mesHealthy);
        uiModel.addAttribute("alarmevent", carrierManagementService.getAlarmEventToDisplay());
        return "lanes/inventory";
    }

    @RequestMapping(params = "inventoryMonitorView", method = RequestMethod.GET)
    public String LanesController.getInventoryMonitorView(@RequestParam(value = "page", required = false) Integer page, @RequestParam(value = "size", required = false) Integer size, Model uiModel) {

        List<DieInventory> dieInventory = CarrierMes.findPartCountsByDies();

        Map<String, Integer> displayRows = new HashMap<String, Integer>();

        for (DieInventory row : dieInventory) {
            if (row.getDieName().contains("R")) {
                displayRows.put(row.getDieName(), 1);
            } else {
                displayRows.put(row.getDieName(), 0);
            }
        }

        Collections.sort(dieInventory, new Comparator() {
            public int compare(Object o1, Object o2) {
                DieInventory p1 = (DieInventory) o1;
                DieInventory p2 = (DieInventory) o2;
                return p1.getDieName().compareToIgnoreCase(p2.getDieName());
            }
        });

        uiModel.addAttribute("dieInventory", dieInventory);
        uiModel.addAttribute("displayRows", displayRows);

        List<DieInventory> kDDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.KD_LINE);
        uiModel.addAttribute("kDDieInventory", kDDieInventory);

        List<DieInventory> weldTwoDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.WELD_LINE_2);
        uiModel.addAttribute("weldTwoDieInventory", weldTwoDieInventory);

        List<DieInventory> weldOneDieInventory = CarrierMes.findPartCountsByDiesByStopArea(StopArea.WELD_LINE_1);
        uiModel.addAttribute("weldOneDieInventory", weldOneDieInventory);

        boolean mesHealthy = !carrierManagementService.isDisconnected();
        uiModel.addAttribute("meshealthy", mesHealthy);

        uiModel.addAttribute("alarmevent", carrierManagementService.getAlarmEventToDisplay());
        return "lanes/inventoryMonitorView";
    }

    private List<DieInventory> LanesController.getDieInventoryWithOutKDInventory(List<DieInventory> totalDieInventory, List<DieInventory> kDDieInventory) {
        List<DieInventory> inventory = new ArrayList<DieInventory>();
        for (DieInventory dieInv : totalDieInventory) {
            DieInventory inv = new DieInventory(dieInv.getId());
            inv.setDieName(dieInv.getDieName());

            DieInventory kdInventory = null;
            for (DieInventory kdInv : kDDieInventory) {
                if (kdInv.getDieName().equals(dieInv.getDieName())) {
                    kdInventory = kdInv;
                    break;
                }
            }

            if (kdInventory != null) {
                Long quantity = dieInv.getQuantity() - kdInventory.getQuantity();
                Long holdQuantity = null, inspQuantity = null;
                if (dieInv.getHoldQuantity() != null && kdInventory.getHoldQuantity() != null) {
                    holdQuantity = dieInv.getHoldQuantity().longValue() - kdInventory.getHoldQuantity().longValue();
                } else {
                    holdQuantity = dieInv.getHoldQuantity();
                }

                if (dieInv.getInspectionRequiredQuantity() != null && kdInventory.getInspectionRequiredQuantity() != null) {
                    inspQuantity = dieInv.getInspectionRequiredQuantity().longValue() - kdInventory.getInspectionRequiredQuantity().longValue();
                } else {
                    inspQuantity = dieInv.getInspectionRequiredQuantity();
                }

                inv.setQuantity(quantity);
                inv.setHoldQuantity(holdQuantity);
                inv.setInspectionRequiredQuantity(inspQuantity);
            } else {
                inv.setQuantity(dieInv.getQuantity());
                inv.setHoldQuantity(dieInv.getHoldQuantity());
                inv.setInspectionRequiredQuantity(dieInv.getInspectionRequiredQuantity());
            }

            inventory.add(inv);
        }

        return inventory;
    }

    private List<DieInventory> LanesController.getDieInventoryWithOutKDInventoryXX(List<DieInventory> totalDieInventory, List<DieInventory> kDDieInventory) {
        List<DieInventory> inventory = new ArrayList<DieInventory>();
        for (DieInventory dieInv : totalDieInventory) {
            DieInventory inv = new DieInventory(dieInv.getId());
            inv.setDieName(dieInv.getDieName());

            DieInventory kdInventory = null;
            for (DieInventory kdInv : kDDieInventory) {
                if (kdInv.getDieName().equals(dieInv.getDieName())) {
                    kdInventory = kdInv;
                    break;
                }
            }

            if (kdInventory != null) {
                Long quantity = dieInv.getQuantity() - kdInventory.getQuantity();
                Long holdQuantity = null, inspQuantity = null;
                if (dieInv.getHoldQuantity() != null && kdInventory.getHoldQuantity() != null) {
                    holdQuantity = dieInv.getHoldQuantity().longValue() - kdInventory.getHoldQuantity().longValue();
                } else {
                    holdQuantity = dieInv.getHoldQuantity();
                }

                if (dieInv.getInspectionRequiredQuantity() != null && kdInventory.getInspectionRequiredQuantity() != null) {
                    inspQuantity = dieInv.getInspectionRequiredQuantity().longValue() - kdInventory.getInspectionRequiredQuantity().longValue();
                } else {
                    inspQuantity = dieInv.getInspectionRequiredQuantity();
                }

                inv.setQuantity(quantity);
                inv.setHoldQuantity(holdQuantity);
                inv.setInspectionRequiredQuantity(inspQuantity);
            } else {
                inv.setQuantity(dieInv.getQuantity());
                inv.setHoldQuantity(dieInv.getHoldQuantity());
                inv.setInspectionRequiredQuantity(dieInv.getInspectionRequiredQuantity());
            }

            inventory.add(inv);
        }

        return inventory;
    }

    @RequestMapping(params = {"find=ByLane", "form"}, method = RequestMethod.GET)
    public String LanesController.findLaneForm(Model uiModel) {
        uiModel.addAttribute("lanes", StorageRow.findAllStorageRows());
        return "lanes/findlane";
    }

    @RequestMapping(params = "find=ByLane", method = RequestMethod.GET)
    public String LanesController.findLaneToResequence(@RequestParam("row") StorageRow row, Model uiModel) {

        LOG.info("Selected lane Max Capacity : " + row.getCapacity());

        List<Carrier> carriers = getCarriers(CarrierMes.getAllCarriersInLane(row.getStop().getId()),row.getStop().getId());
        Integer[] carrierNumbers = new Integer[carriers.size()];
        int i = 0;
        for (Carrier carrier : carriers) {
            carrierNumbers[i] = carrier.getCarrierNumber();
            i++;
        }
        boolean allowInsert = true;
        boolean allowDelete = true;

        if (carriers.size() >= row.getCapacity()) {
            allowInsert = false;
        }

        if (carriers.size() < 1) {
            allowDelete = false;
        }
        uiModel.addAttribute("carriers", carrierNumbers);
        uiModel.addAttribute("maxcapacity", row.getCapacity());
        uiModel.addAttribute("carriercount", carriers.size() + 1);
        uiModel.addAttribute("allowinsert", allowInsert);
        uiModel.addAttribute("allowdelete", allowDelete);
        uiModel.addAttribute("stop", row.getStop().getId());
        uiModel.addAttribute("message", "");
        uiModel.addAttribute("lanename", row.getRowName());

        boolean mesHealthy = carrierManagementService.isDisconnected() ? false : true;
        uiModel.addAttribute("meshealthy", mesHealthy);
        uiModel.addAttribute("alarmevent", carrierManagementService.getAlarmEventToDisplay());
        return "lanes/resequence";
    }


    @RequestMapping(method = RequestMethod.PUT)
    public String LanesController.update(@RequestParam("carriernumber") String[] carriernumbers, @RequestParam("stopConveyorId") Long stopConveyorId,
                                         ArrayList<Carrier> carrierlist, BindingResult bindingResult, Model uiModel, HttpServletRequest httpServletRequest) {
        LOG.debug("carriers length" + carriernumbers.length);
        Stop laneStop = Stop.findStop(stopConveyorId);
        List<Carrier> carriers = new ArrayList<Carrier>();
        ArrayList<Integer> carrierNumberList = new ArrayList<Integer>();
        String message = "";
        carriers.clear();
        for (int i = 0; i < carriernumbers.length; i++) {
            if (carriernumbers[i] != null && carriernumbers[i].length() > 0) {
                LOG.info(carriernumbers[i]);
                try {
                    int carrierNumber = Integer.parseInt(carriernumbers[i]);

                    CarrierMes carrierMes = CarrierMes.findCarrierByCarrierNumber(carrierNumber);
                    if (carrierMes != null) {
                        Stop currentLocation = Stop.findStop(carrierMes.getCurrentLocation());
                        if (currentLocation.isRowStop()) {
                            LOG.info("Please resequence " + currentLocation);
                        }
                        Carrier c = new Carrier();
                        c.setCarrierNumber(carrierNumber);
                        c.setCurrentLocation(laneStop);
                        c.setDestination(laneStop);
                        if (i == 0) {
                            c.setBuffer(1);
                        } else {
                            c.setBuffer(0);
                        }
                        carriers.add(c);
                        carrierNumberList.add(Integer.valueOf(carriernumbers[i]));
                    } else {
                        LOG.info(" invalid Carrier-" + carrierNumber);
                        message = " Carrier -" + carrierNumber + " does not exist";
                        break;
                    }
                } catch (Exception e) {
                    LOG.info("invalid parameter--" + carriernumbers[i]);
                    message = "Invalid carrier number At position-" + (i + 1);
                    // e.printStackTrace();
                }

            }
        }
        if (message == null || message.length() == 0) {
            LOG.info("Resequence Carriers To Row by user " + getSource());
            carrierManagementServiceProxy.saveCarriersInToRow(carrierNumberList, laneStop);
        }

        StorageRow selectedLane = StorageRow.findStorageRowsByStop(laneStop);
        boolean allowInsert = true;
        boolean allowDelete = true;

        List<Carrier> carriersList = getCarriers(CarrierMes.getAllCarriersInLane(laneStop.getId()),laneStop.getId()) ;
        if (carriersList.size() >= selectedLane.getCapacity()) {
            allowInsert = false;
        }

        if (carriersList.size() < 1) {
            allowDelete = false;
        }

        uiModel.addAttribute("carriers", carriernumbers);
        uiModel.addAttribute("maxcapacity", selectedLane.getCapacity());
        uiModel.addAttribute("carriercount", carriersList.size() + 1);
        uiModel.addAttribute("allowinsert", allowInsert);
        uiModel.addAttribute("allowdelete", allowDelete);
        uiModel.addAttribute("stop", selectedLane.getStop().getId());
        uiModel.addAttribute("message", message);
        boolean mesHealthy = !carrierManagementService.isDisconnected();
        uiModel.addAttribute("meshealthy", mesHealthy);


        return "lanes/resequence";
    }

    @RequestMapping(params = "carrier=insert", method = RequestMethod.PUT)
    public String LanesController.insertCarrier(@RequestParam("carriernumberinsert") String carriernumbers, @RequestParam("carrierposition") String carrierPosition, @RequestParam("stopConveyorId") Long stopConveyorId,
                                                ArrayList<Carrier> carriers, BindingResult bindingResult, Model uiModel, HttpServletRequest httpServletRequest) {
        LOG.debug("insert carrier");
        Stop laneStop = Stop.findStop(stopConveyorId);
        String message = "";
        LOG.info(carriernumbers);
        try {
            Integer carrierNumber = new Integer(Integer.parseInt(carriernumbers));
            Integer position = new Integer(Integer.parseInt(carrierPosition));

            CarrierMes carrierMes = CarrierMes.findCarrierByCarrierNumber(carrierNumber);
            if (carrierMes != null) {
                LOG.info("Add Carrier To Row by user " + getSource());
                carrierManagementServiceProxy.addCarrierToRow(carrierNumber, position, laneStop);
            } else {
                LOG.info("invalid Carrier-" + carrierNumber);
                message = "Invalid Carrier-" + carrierNumber;
            }

        } catch (Exception e) {
            LOG.info("invalid parameter--" + carriernumbers);
            e.printStackTrace();
            message = "Invalid carrier number provided to insert";
        }

        StorageRow selectedLane = StorageRow.findStorageRowsByStop(laneStop);
        boolean allowInsert = true;
        boolean allowDelete = true;
        List<Carrier> carriersList = getCarriers(CarrierMes.getAllCarriersInLane(laneStop.getId()),laneStop.getId()) ;
        Integer[] carrierNumbers = new Integer[carriersList.size()];
        int i = 0;
        for (Carrier carrier : carriersList) {
            carrierNumbers[i] = carrier.getCarrierNumber();
            i++;
        }
        if (carriersList.size() >= selectedLane.getCapacity()) {
            allowInsert = false;
        }

        if (carriersList.size() < 1) {
            allowDelete = false;
        }

        uiModel.addAttribute("carriers", carrierNumbers);
        uiModel.addAttribute("maxcapacity", selectedLane.getCapacity());
        uiModel.addAttribute("carriercount", carriersList.size() + 1);
        uiModel.addAttribute("allowinsert", allowInsert);
        uiModel.addAttribute("allowdelete", allowDelete);
        uiModel.addAttribute("stop", selectedLane.getStop().getId());
        uiModel.addAttribute("insertmessage", message);
        uiModel.addAttribute("message", "");
        boolean mesHealthy = !carrierManagementService.isDisconnected();
        uiModel.addAttribute("meshealthy", mesHealthy);

        return "lanes/resequence";

    }

    @RequestMapping(params = "carrier=remove", method = RequestMethod.PUT)
    public String LanesController.removeCarrier(@RequestParam("carriernumberdelete") String carriernumbers, @RequestParam("stopConveyorId") Long stopConveyorId,
                                                ArrayList<Carrier> carriers, BindingResult bindingResult, Model uiModel, HttpServletRequest httpServletRequest) {
        LOG.debug("remove carrier");
        Stop laneStop = Stop.findStop(stopConveyorId);
        LOG.info(carriernumbers);
        try {
            LOG.info("Remove Carrier From Row by user " + getSource());
            Integer carrierNumber = new Integer(Integer.parseInt(carriernumbers));
            carrierManagementServiceProxy.removeCarrierFromRow(carrierNumber);

        } catch (Exception e) {
            LOG.info("invalid parameter--" + carriernumbers);
            e.printStackTrace();
        }

        StorageRow selectedLane = StorageRow.findStorageRowsByStop(laneStop);
        boolean allowInsert = true;
        boolean allowDelete = true;

        Integer[] carrierNumbers = new Integer[selectedLane.getCurrentCarrierCount()];
        int i = 0;
        for (Carrier carrier : selectedLane.getCarriersAsLinkedList()) {
            carrierNumbers[i] = carrier.getCarrierNumber();
            i++;
        }
        if (selectedLane.getCurrentCarrierCount() >= selectedLane.getCapacity()) {
            allowInsert = false;
        }

        if (selectedLane.getCurrentCarrierCount() == 0) {
            allowDelete = false;
        }

        uiModel.addAttribute("carriers", carrierNumbers);
        uiModel.addAttribute("maxcapacity", selectedLane.getCapacity());
        uiModel.addAttribute("carriercount", selectedLane.getCurrentCarrierCount() + 1);
        uiModel.addAttribute("allowinsert", allowInsert);
        uiModel.addAttribute("allowdelete", allowDelete);
        uiModel.addAttribute("stop", selectedLane.getStop().getId());
        uiModel.addAttribute("insertmessage", "");
        uiModel.addAttribute("message", "");
        boolean mesHealthy = !carrierManagementService.isDisconnected();
        uiModel.addAttribute("meshealthy", mesHealthy);

        return "lanes/resequence";
    }


    @RequestMapping(params = "ByEmpty", method = RequestMethod.GET)
    public String LanesController.manuallyReleaseEmptyForm(org.springframework.ui.Model uiModel) {
        return "lanes/manualemptyrelease";
    }

    @RequestMapping(params = "find=ByEmpty", method = RequestMethod.GET)
    public String LanesController.manuallyReleaseEmpty(@RequestParam("area") StorageArea area, @RequestParam("releaseManager") boolean releaseManager, org.springframework.ui.Model uiModel) {
        String source = getSource();
        LOG.info("Manual Empty : Area - " + area.toString() + "  by user- " + source);
        carrierManagementServiceProxy.releaseEmptyCarriersFromRows(area, releaseManager, source);
        uiModel.asMap().clear();


        return "redirect:/lanes";
    }

    @RequestMapping(params = "ByRow", method = RequestMethod.GET)
    public String LanesController.manuallyOrderFulfillmentForm(org.springframework.ui.Model uiModel) {
        List<Stop> stops = carrierManagementService.getManualOrderCarrierDeliveryStops();

        uiModel.addAttribute("rows", StorageRow.findAllStorageRows());
        uiModel.addAttribute("counts", getCounts());
        uiModel.addAttribute("stops", stops);
        return "lanes/manualorderfulfillment";
    }

    @RequestMapping(params = "find=ByRow", method = RequestMethod.GET)
    public String LanesController.manuallyOrderFulfillment(@RequestParam("row") StorageRow row, @RequestParam("count") Integer count, @RequestParam("destination") Stop destination, org.springframework.ui.Model uiModel) {

        SecurityContext context = SecurityContextHolder.getContext();
        UserDetails principal = (UserDetails) context.getAuthentication().getPrincipal();
        String source = getSource();
        LOG.info("manual order : Row - " + row.getRowName() + ", Carrier count - " + count + " , Destination - " + destination.getName() + " , by user " + source);
        carrierManagementServiceProxy.releaseCarriers(row, count, destination, source);
        uiModel.asMap().clear();

        return "redirect:/lanes";
    }


    @ModelAttribute("areas")
    public Collection<StorageArea> LanesController.populateStorageAreas() {
        StorageArea[] a = {StorageArea.C_HIGH, StorageArea.C_LOW, StorageArea.A_AREA, StorageArea.B_AREA};
        return Arrays.asList(a);
    }

    private List<StorageRow> LanesController.filterCarriersInLanes(List<StorageRow> lanes) {
        List<StorageRow> tempLanes = new ArrayList<StorageRow>();
        for (StorageRow lane : lanes) {

            List<CarrierMes> carrierMesList = CarrierMes.getAllCarriersInLane(lane.getStop().getId());
            List<Carrier> carriers = getCarriers(carrierMesList, lane.getStop().getId());

            for (Carrier carrier : carriers) {
                if (carrier.getDie() == null) {
                    Die noDie = new Die(0L, PartProductionVolume.LOW_VOLUME);
                    noDie.setBackgroundColor("#FF0000");
                    noDie.setTextColor("#FFFF00");
                    carrier.setDie(noDie);
                }
                lane.uiDisplayUseOnlyAddCarrier(carrier);
            }
            tempLanes.add(lane);

        }
        return tempLanes;
    }


    private List<Carrier> LanesController.getCarriers(List<CarrierMes> carrierMesList, Long stopId) {

        List<Carrier> carriersList = new ArrayList<Carrier>();

        List<Carrier> inRowCarriers = new ArrayList<Carrier>();
        List<Carrier> inRouteCarriers = new ArrayList<Carrier>();
        if (carrierMesList != null) {
            for (CarrierMes carrierMes : carrierMesList) {
                Carrier c = new Carrier();
                c.setId(carrierMes.getId());
                c.setCarrierNumber(carrierMes.getCarrierNumber());
                c.setCarrierStatus(CarrierStatus.findByType(carrierMes.getStatus()));
                c.setQuantity(carrierMes.getQuantity());
                c.setDie(Die.findDie(new Long(carrierMes.getDieNumber().intValue())));

                if (carrierMes.getCurrentLocation().equals(stopId)) {
                    if (carrierMes.getDestination().equals(stopId)) {
                        Long carrierNumber = Long.parseLong(carrierMes.getCarrierNumber().toString());
                        CarrierRelease release = CarrierRelease.findCarrierRelease(carrierNumber);
                        if (release == null) {
                            c.setAlreadyInLane(true);
                            c.setMovingOutOfLane(false);
                            c.setInQueueToMoveOutOfLane(false);
                            c.setMovingInToLane(false);
                        } else {
                            c.setAlreadyInLane(false);
                            c.setMovingOutOfLane(false);
                            c.setInQueueToMoveOutOfLane(true);
                            c.setMovingInToLane(false);
                        }

                        inRowCarriers.add(c);
                    } else {
                        c.setAlreadyInLane(false);
                        c.setMovingOutOfLane(true);
                        c.setInQueueToMoveOutOfLane(false);
                        c.setMovingInToLane(false);
                        inRowCarriers.add(c);
                    }
                } else {
                    if (carrierMes.getDestination().equals(stopId)) {
                        c.setAlreadyInLane(false);
                        c.setMovingOutOfLane(false);
                        c.setInQueueToMoveOutOfLane(false);
                        c.setMovingInToLane(true);
                        inRouteCarriers.add(c);
                    }
                }
            }
        }

        for (Carrier carrier : inRowCarriers) {
            carriersList.add(carrier);
        }

        for (Carrier carrier : inRouteCarriers) {
            carriersList.add(carrier);
        }
        return carriersList;
    }

    private String LanesController.getSource() {
        SecurityContext context = SecurityContextHolder.getContext();
        UserDetails principal = (UserDetails) context.getAuthentication().getPrincipal();
        String source = "";
        if (principal != null) source = principal.getUsername();
        return source;
    }

    private List<Integer> LanesController.getCounts() {
        List<Integer> counts = new ArrayList<Integer>();
        counts.add(new Integer(1));
        counts.add(new Integer(2));
        counts.add(new Integer(3));
        counts.add(new Integer(4));
        counts.add(new Integer(5));
        counts.add(new Integer(6));

        return counts;
    }

    @ModelAttribute("carrierstatuses")
    public Collection<CarrierStatus>LanesController.populateCarrierStatuses() {
        return Arrays.asList(CarrierStatus.class.getEnumConstants());
    }

    @ModelAttribute("dies")
    public Collection<Die>LanesController.populateDies() {
        return Die.findAllDies();
    }

    @ModelAttribute("presses")
    public Collection<Press>LanesController.populatePresses() {
        return Arrays.asList(Press.class.getEnumConstants());
    }

    @ModelAttribute("stops")
    public Collection<Stop>LanesController.populateStops() {
        return Stop.findAllStops();
    }
}
